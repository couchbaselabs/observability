// Copyright (C) 2022 Couchbase, Inc.
//
// Use of this software is subject to the Couchbase Inc. License Agreement
// which may be found at https://www.couchbase.com/LA03012021.

package hazelnut

import (
	"bytes"
	"errors"
	"io"
	"regexp"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/couchbaselabs/cbmultimanager/cluster-monitor/pkg/values"

	"go.uber.org/zap"

	"github.com/couchbaselabs/cbmultimanager/agent/pkg/health/store"
)

var testMsgpack = []byte{
	0x92, 0xd7, 0x00, 0x61, 0xe6, 0x8b, 0x92, 0x33, 0x7f, 0x98, 0x00, 0x89, 0xa9, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x70,
	0x61, 0x74, 0x68, 0xd9, 0x25, 0x2f, 0x6f, 0x70, 0x74, 0x2f, 0x63, 0x6f, 0x75, 0x63, 0x68, 0x62, 0x61, 0x73, 0x65,
	0x2f, 0x76, 0x61, 0x72, 0x2f, 0x6c, 0x69, 0x62, 0x2f, 0x63, 0x6f, 0x75, 0x63, 0x68, 0x62, 0x61, 0x73, 0x65, 0x2f,
	0x6c, 0x6f, 0x67, 0x73, 0xa4, 0x66, 0x69, 0x6c, 0x65, 0xaa, 0x67, 0x6f, 0x78, 0x64, 0x63, 0x72, 0x2e, 0x6c, 0x6f,
	0x67, 0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xd9, 0x30, 0x2f, 0x6f, 0x70, 0x74, 0x2f, 0x63, 0x6f,
	0x75, 0x63, 0x68, 0x62, 0x61, 0x73, 0x65, 0x2f, 0x76, 0x61, 0x72, 0x2f, 0x6c, 0x69, 0x62, 0x2f, 0x63, 0x6f, 0x75,
	0x63, 0x68, 0x62, 0x61, 0x73, 0x65, 0x2f, 0x6c, 0x6f, 0x67, 0x73, 0x2f, 0x67, 0x6f, 0x78, 0x64, 0x63, 0x72, 0x2e,
	0x6c, 0x6f, 0x67, 0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0xb8, 0x32, 0x30, 0x32, 0x32, 0x2d,
	0x30, 0x31, 0x2d, 0x31, 0x38, 0x54, 0x30, 0x39, 0x3a, 0x34, 0x32, 0x3a, 0x34, 0x32, 0x2e, 0x38, 0x36, 0x34, 0x5a,
	0xa5, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0xa4, 0x49, 0x4e, 0x46, 0x4f, 0xa7, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0xd9, 0x2f, 0x20, 0x47, 0x4f, 0x58, 0x44, 0x43, 0x52, 0x2e, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x4d,
	0x67, 0x72, 0x3a, 0x20, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x20, 0x3d, 0x20, 0x6d, 0x61, 0x70, 0x5b, 0x5d, 0xa8, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d,
	0x65, 0xa9, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, 0xaa, 0x6c, 0x6f, 0x67, 0x73, 0x68, 0x69, 0x70,
	0x70, 0x65, 0x72, 0xbb, 0x63, 0x6f, 0x75, 0x63, 0x68, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x73, 0x69, 0x64, 0x65, 0x63,
	0x61, 0x72, 0x2e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x74, 0x62, 0x69, 0x74, 0xa9, 0x63, 0x6f, 0x75, 0x63, 0x68, 0x62,
	0x61, 0x73, 0x65, 0x82, 0xa7, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0xb3, 0x36, 0x2e, 0x36, 0x2e, 0x33, 0x20,
	0x74, 0x65, 0x73, 0x74, 0x20, 0x28, 0x55, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x29, 0xa4, 0x6e, 0x6f, 0x64, 0x65, 0xa9,
	0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,
}

var testJSON = []byte(`{
"date": 1642498962864000000,
"file_path": "/opt/couchbase/var/lib/couchbase/logs",
"file": "goxdcr.log",
"filename": "/opt/couchbase/var/lib/couchbase/logs/goxdcr.log",
"timestamp": "2022-01-18T09:42:42.864Z",
"level": "INFO",
"message": " GOXDCR.PipelineMgr: Replication Status = map[]",
"hostname": "localhost",
"logshipper": "couchbase.sidecar.fluentbit",
"couchbase": {"cluster": "6.6.3 test (Ubuntu)", "node": "localhost"}}
`)

var testRules = map[string][]rule{"goxdcr.log": {
	rule{
		File:     "goxdcr.log",
		Contains: "Replication Status",
		Regexp:   stringRegexp{regexp.MustCompile(`Replication Status = (.*)$`)},
		CustomFields: customFields{
			customField{
				FieldName: "logshipper",
				Type:      "string",
				Regexp:    stringRegexp{regexp.MustCompile(`.*fluentbit`)},
			},
		},
		Result: values.CheckerResult{
			Name:        "test",
			Status:      values.WarnCheckerStatus,
			Remediation: "Replication status is $1",
		},
		Hints: map[string]interface{}{
			"level": "INFO",
		},
	},
}}

type mockNode struct {
	clusterUUID string
	uuid        string
}

func (n *mockNode) UUID() string {
	return n.uuid
}

func (n *mockNode) ClusterUUID() string {
	return n.clusterUUID
}

func TestAnalyzeMsgpack(t *testing.T) {
	memStore := store.NewInMemoryStore()
	testNode := mockNode{
		uuid:        "node_uuid",
		clusterUUID: "cluster_uuid",
	}
	r := Receiver{
		logger:      zap.NewNop(),
		resultStore: memStore,
		fileRules:   testRules,
		node:        &testNode,
	}
	err := r.processMessages(bytes.NewReader(testMsgpack))
	if err != nil && !errors.Is(err, io.EOF) {
		require.NoError(t, err)
	}
	result, _ := memStore.GetCheckerResult("test")
	require.Equal(t, values.WarnCheckerStatus, result.Result.Status)
}

func TestAnalyzeJSON(t *testing.T) {
	memStore := store.NewInMemoryStore()
	testNode := mockNode{
		uuid:        "node_uuid",
		clusterUUID: "cluster_uuid",
	}
	r := Receiver{
		logger:      zap.NewNop(),
		resultStore: memStore,
		fileRules:   testRules,
		node:        &testNode,
	}
	err := r.processMessages(bytes.NewReader(testJSON))
	if err != nil && !errors.Is(err, io.EOF) {
		require.NoError(t, err)
	}
	result, _ := memStore.GetCheckerResult("test")
	require.Equal(t, values.WarnCheckerStatus, result.Result.Status)
}
