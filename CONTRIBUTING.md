# Contributing to CMOS

Thank you for taking the time to contribute to CMOS! This guide is a set of guidelines as well as tips to make contributing easier.

## Reporting Issues

All issues related to CMOS are tracked on the [CMOS project](https://issues.couchbase.com/browse/CMOS) on the Couchbase JIRA. The project is public, as are the vast majority of issues, so feel free to file one if you spot an issue or have an idea for an improvement. Please don't keep these to yourself, filing an issue is helpful even if you don't intend to write the code yourself!

When filing an issue, please set the appropriate type (bug / improvement / new feature / task) and components.

## Code Style Guidelines

As CMOS is an amalgamation of various other projects, as well as some code of our own, we use various languages and tools.

The majority of these standards are enforced by linters - you can run all the linters by running `make lint`. If this passes, your code is probably good to go!

### Golang (Configuration Service)

In general, follow [gofumpt](https://github.com/mvdan/gofumpt). We use [golangci-lint](https://golangci-lint.run/) to enforce it.

### Bash (testing)

Run shellcheck on your code (this will be done automatically as part of the CI process).

By convention, use `lower_snake_case` for variables that only live inside the current function / test case, and `UPPER_SNAKE_CASE` for global variables.

### YAML (configuration files and Ansible playbooks)

Run yamllint and yamlfmt over your code, this will ensure it adheres to the style.

### Dockerfiles

Run hadolint over your files.

## Code Contribution Workflow

To start, follow the setup instructions in README.md.

Please use a descriptive Git branch name - ideally every change should be associated with a CMOS issue, so name your branch something like `CMOS-1234`.

Please follow this format for your commit messages, as this means they will automatically be associated with Jira tickets when you submit them for review:


> CMOS-1234: Fix the frobnicator
>
> A longer description of the background to this commit and the issue it fixes. Sometimes commit messages can be longer than the actual code changes, in which case having the additional context is invaluable.
>
> Write your commit message in the imperative: "Fix bug" and not "Fixed bug" or "Fixes bug."  This convention matches up with commit messages generated by commands like git merge and git revert.

## Pre-Commit Checklist

Before committing your changes, it's a good idea to run through this checklist. All of this is also enforced by automated CI, so you will not be able to submit your changes unless this passes, but running it locally may save you time.

* Does it work? (`make container`, then run the built image and test your feature / bug fix - note that if you do not have access to the couchbaselabs GitHub organisation you may not be able to do this, in this case skip this step and a maintainer can test it for you)
* Does it work in the OSS build (i.e. without the proprietary Couchbase Cluster Monitor)? (Run `make container-oss` and repeat the above)
* Do the linters pass? (`make lint`)
* Do the tests pass? (See below)
* If you have added substantial new code, is it covered by tests? (Not obligatory, but it's much easier than writing them after the fact!)
* If you have added any new third party components that are not tracked by go.mod or other package managers, have you added them to the `CONTRIBUTORS` and `README.md` files?
* If you have left any TODO comments, have you filed an associated CMOS issue? (Otherwise they may get forgotten.)
* If you have made changes to the build or packaging infrastructure, have you validated they will work with Couchbase's internal build infrastructure? (If you're not sure what this means, just ask a maintainer, and they'll help you out.)

Once all the above can be ticked off, go ahead and file a pull request! If you are not a member of the couchbaselabs GitHub organization, you may need to fork the repository - the process is explained on this [GitHub help article](https://docs.github.com/en/get-started/quickstart/contributing-to-projects).

When your pull request is in, it will automatically have a battery of automatic tests and linters run against it, and it will be reviewed by a human (another developer on the project). If either of these come back to you with change requests, don't panic - simply fix up your code, push a new commit, and repeat the process until it is ready for merge. Don't feel put down if we request changes - even our most experienced developers rarely have a perfect PR on the first try.

## Testing

The testing philosophy of this project is described in [README.md](/README.md#testing) - it is somewhat unconventional, since the project is not a single piece of code but rather an amalgamation of various other tools all plumbed together.

Our tests are implemented in Bash using the [BATS framework](https://bats-core.readthedocs.io/en/stable/).

CMOS targets three deployment platforms of Couchbase Server: "native" (bare-metal or VMs), "containers" (Docker or otherwise), and "kubernetes" (using the [Couchbase Autonomous Operator](https://www.couchbase.com/products/cloud/kubernetes)). Each of these suites has its own set of "integration" tests, in the `testing/bats/integration/{native,containers,kubernetes}` directories. There is also a "smoke" suite of tests that are run against all deployment models.

You can run each platform's tests by running `make test-native`, `make test-containers`, or `make test-kubernetes`, or you can run them all by running `make test` (this may take a while!). You can also specify which test suite to run, e.g. `make -e TEST_SUITE=smoke test-native`.

To run each platform's tests, you will need:

* Native: [Vagrant](http://vagrantup.com/) and [VirtualBox](https://www.virtualbox.org/)
* Containers: a Docker daemon (on Windows or macOS you can use Docker Desktop)
* Kubernetes: same as above, plus either a running Kubernetes cluster or [kind](https://kind.sigs.k8s.io/)
  * If you use the latter, set the environment variable `SKIP_CLUSTER_CREATION=no` and the tests will take care of starting up an isolated cluster.

If your tests fail, and you want to poke around in the environment they were running in to understand why, set the environment variable `SKIP_TEARDOWN=true`. Note that this means you will have to clean up yourself afterwards.

### Automation

These tests are also run automatically using GitHub Actions. However, since setting up VMs and a Kubernetes cluster can be slow, we *only* run the containers smoke suite on pull requests. We run the full suite of tests every night, or manually upon request by a maintainer.
